const { blinqClick } = require('../utils/blinqClick');

async function submitPolicyForApproval(page, page1, submissionNumber) {
  submissionNumber = submissionNumber || "3003177786"; // Example submission number

  // 1️⃣ Login
  await page1.goto('https://qa-policycenter.donegalgroup.com/pc/PolicyCenter.do');
  await page1.getByRole('textbox', { name: 'Username' }).fill('amitmish');
  await page1.getByRole('textbox', { name: 'Password' }).fill('gw');
  await page1.getByRole('textbox', { name: 'Password' }).press('Enter');

  // 2️⃣ Navigate to submission
  await page1.getByRole('menuitem', { name: 'Policy', exact: true }).click();
  await page1.locator('#TabBar-PolicyTab > .gw-action--expand-button > .gw-icon').click();
  await page1.locator('input[name="TabBar-PolicyTab-PolicyTab_SubmissionNumberSearchItem"]').fill(submissionNumber);
  await page1.getByLabel('Sub #').getByRole('button', { name: 'gw-search-icon' }).click();
  await page.waitForLoadState('networkidle');

  //onsole.log(await page1.locator('#LeftNavContainer, .leftNav, #LeftNav').first().innerHTML().catch(()=>'')); 
  //await page1.screenshot({ path: 'left-nav-before-click.png' });

  // 3️⃣ Click Risk Analysis using Blinq-style locators
  const riskAnalysisLocators = [
    // Semantic/text-based
    'internal:text="Risk Analysis"i',
    'internal:text="Risk Analysis"s',
    'div >> internal:has-text=/^Risk Analysis$/',
    // Scoped Gw-specific classes often used in PolicyCenter left-nav
    '#LeftNavContainer >> .gw-action--inner:has-text("Risk Analysis")',
    '.gw-action--inner:has-text("Risk Analysis")',
    '.gw-actionable:has-text("Risk Analysis")',
    // Fallbacks that match containing text
    'text=/^\\s*Risk Analysis\\s*$/i',
    'internal:text="QuQualificationPCPolicy"i >> div >> internal:has-text="Risk Analysis"i',
    'internal:text="QuQualificationPCPolicy ContractPIPolicy"i >> div >> internal:has-text="Risk Analysis"i'
  ];

  // Before clicking, capture the left-nav DOM and screenshot to help diagnose selector issues
  const leftNavSelectors = ['#LeftNavContainer', '.leftNav', '#LeftNav', '.gw-left-nav', '#LeftNavContainer-0'];
  let foundScope = null;
  for (const s of leftNavSelectors) {
    try {
      const loc = page1.locator(s);
      if (await loc.count() > 0) {
        foundScope = s;
        try {
          const html = await loc.first().innerHTML();
          console.log(`Left-nav HTML for scope '${s}':\n${html.slice(0, 2000)}`);
        } catch (e) {
          console.warn(`Could not read innerHTML for scope '${s}': ${e.message}`);
        }
        try {
          const out = 'left-nav-before-click.png';
          await loc.first().screenshot({ path: out }).catch(() => { });
          console.log(`Saved left-nav screenshot: ${out}`);
        } catch (e) {
          console.warn(`Could not screenshot left-nav for scope '${s}': ${e.message}`);
        }
        break;
      }
    } catch (err) {
      // ignore and try next
    }
  }

  // If we didn't find a left-nav scope, save a full-page screenshot into test-results
  if (!foundScope) {
    try {
      const out = 'test-results/left-nav-before-click.png';
      await page1.screenshot({ path: out, fullPage: true });
      console.log(`Saved full-page left-nav screenshot fallback: ${out}`);
    } catch (e) {
      console.warn(`Could not save fallback full-page screenshot: ${e.message}`);
    }
  }

  const ok = await blinqClick(page1, riskAnalysisLocators, { scope: foundScope || undefined, aggressive: true });
  if (!ok) {
    console.warn('blinqClick did not find/click Risk Analysis — attempting manual bounding-box click fallback');
    try {
      // Try to find a visible element with exact text and click its center via mouse (helps with custom widgets)
      const candidates = page1.locator('text=/^\\s*Risk Analysis\\s*$/i');
      const count = await candidates.count();
      for (let i = 0; i < count; i++) {
        const c = candidates.nth(i);
        if (!(await c.isVisible())) continue;
        await c.scrollIntoViewIfNeeded();
        const box = await c.boundingBox();
        if (box) {
          const x = box.x + box.width / 2;
          const y = box.y + box.height / 2;
          await page1.mouse.move(x, y);
          await page1.mouse.click(x, y, { timeout: 60000 });
          console.log('➡️ Manual bounding-box click performed on Risk Analysis');
          // give app a moment to react
          await page1.waitForTimeout(500);
          return;
        }
      }
    } catch (fbErr) {
      console.warn('Manual fallback failed:', fbErr.message);
    }
    throw new Error("Risk Analysis click failed");
  }
  // 4️⃣ Special Approve discovery + click loop
  // Wait for Risk Analysis panel or relevant container to load (best-effort)
  try {
    const riskPanel = page1.locator('div[id*="RiskAnalysis"], #SubmissionWizard-Job_RiskAnalysisScreen');
    await riskPanel.first().waitFor({ state: 'visible', timeout: 10000 }).catch(() => {});
  } catch (e) {
    // ignore - best-effort
  }

  // Prioritized selectors to try for Special Approve
  const specialSelectors = [
    'div[id*="SpecialApprove"]',
    'div.gw-LinkWidget:has-text("Special Approve")',
    'div.gw-actionable:has(div.gw-actionable--inner:text("Special Approve"))',
    'div:has-text("Special Approve")',
    'text=/\\bSpecial Approve\\b/'
  ];

  let foundHandles = [];
  for (const sel of specialSelectors) {
    try {
      const loc = page1.locator(sel);
      const count = await loc.count();
      console.log(`Trying selector: ${sel} -> count=${count}`);
      if (count > 0) {
        foundHandles = await loc.elementHandles();
        console.log(`✅ Selector matched (${sel}) — found ${foundHandles.length} handles`);
        break;
      }
    } catch (e) {
      console.warn(`Selector ${sel} threw: ${e.message}`);
    }
  }

  if (foundHandles.length === 0) {
    console.warn('Special Approve buttons found: 0 — collecting diagnostics');
    try {
      const diagOut = 'test-results/special-approve-failure.png';
      await page1.screenshot({ path: diagOut, fullPage: true }).catch(() => {});
      console.log(`Saved full-page screenshot: ${diagOut}`);
    } catch (e) {
      console.warn('Could not save diagnostic screenshot:', e.message);
    }
    try {
      const scope = page1.locator('div[id*="RiskAnalysis"], #SubmissionWizard-Job_RiskAnalysisScreen');
      if (await scope.count() > 0) {
        const html = await scope.first().innerHTML().catch(() => '');
        console.log('RiskAnalysis container innerHTML (first 2000 chars):', html.slice(0, 2000));
      } else {
        const bodyHtml = await page1.locator('body').first().innerHTML().catch(() => '');
        console.log('Body innerHTML (first 2000 chars):', bodyHtml.slice(0, 2000));
      }
    } catch (e) {
      console.warn('Could not capture diagnostic innerHTML:', e.message);
    }
    // Try searching inside frames (if Special Approve rendered in an iframe)
    try {
      const frames = page1.frames();
      console.log(`Page has ${frames.length} frames`);
      for (const f of frames) {
        try {
          const fn = f.name() || '<no-name>';
          const furl = f.url() || '<no-url>';
          // Try simple selector first
          for (const sel of specialSelectors) {
            try {
              const cnt = await f.locator(sel).count();
              if (cnt > 0) {
                console.log(`Frame ${fn} (${furl}) matched selector ${sel} -> count=${cnt}`);
                foundHandles = await f.locator(sel).elementHandles();
                break;
              }
            } catch (se) {
              // ignore selector errors per-frame
            }
          }
          if (foundHandles.length > 0) break;
        } catch (fe) {
          console.warn('Frame search error:', fe.message);
        }
      }
    } catch (e) {
      console.warn('Could not search frames for Special Approve:', e.message);
    }

    // As a last resort, run a raw DOM query to surface any matching elements' outerHTML
    try {
      const matches = await page1.evaluate(() => {
        const sels = ['[id*="SpecialApprove"]', '.gw-LinkWidget', '.gw-actionable'];
        const out = [];
        for (const s of sels) {
          const els = Array.from(document.querySelectorAll(s));
          for (const e of els) {
            out.push({ selector: s, id: e.id || null, class: e.className || null, text: e.innerText ? e.innerText.trim() : '' , outer: e.outerHTML ? e.outerHTML.slice(0,1000) : '' });
          }
        }
        return out.slice(0,50);
      }).catch(() => null);
      if (matches && matches.length > 0) {
        console.log('Page-level raw query found elements (sample):', JSON.stringify(matches, null, 2));
      } else {
        console.log('Page-level raw query found no matching elements');
      }
    } catch (e) {
      console.warn('Raw DOM query failed:', e.message);
    }
  } else {
    // Simple Special Approve loop — revert to earlier behavior
    const specialApproveButtons = await page1.locator('div[id*="SpecialApprove"][class*="gw-LinkWidget"], div.gw-LinkWidget:has-text("Special Approve")').elementHandles();
    console.log('Special Approve buttons found:', specialApproveButtons.length);
    if (specialApproveButtons.length === 0) {
      console.warn("No Special Approve buttons found — skipping loop");
    } else {
      for (const btn of specialApproveButtons) {
        await btn.scrollIntoViewIfNeeded();
        try {
          await btn.click({ timeout: 60000 });
          console.log("➡️ Clicked Special Approve button");
        } catch (clickErr) {
          console.warn('Special Approve direct click failed, attempting bounding-box click:', clickErr.message);
          const box = await btn.boundingBox();
          if (box) {
            await page1.mouse.move(box.x + box.width / 2, box.y + box.height / 2);
            await page1.mouse.click(box.x + box.width / 2, box.y + box.height / 2, { timeout: 60000 });
            console.log('➡️ Performed bounding-box click on Special Approve');
          }
        }

        // Handle Guidewire custom modal (data-gw-confirm)
        const gwDialog = page1.locator('div.gw-messageBox, div.gw-dialog');
        if (await gwDialog.count() > 0) {
          const okButton = gwDialog.locator('button:has-text("OK")');
          if (await okButton.count() > 0) {
            await okButton.click({ timeout: 10000 });
            console.log("✅ Custom GW dialog OK clicked");
          }
        }

        // Handle second OK button on page
        const secondOk = page1.getByRole('button', { name: 'OK' });
        if (await secondOk.count() > 0) {
          await secondOk.click({ timeout: 10000 });
          console.log("✅ Second OK clicked");
        }

        await page1.waitForTimeout(500);
      }
    }
  }
}


  // Continue with Release, Bind, Issue, etc. using blinqClick similarly


module.exports = { submitPolicyForApproval };
